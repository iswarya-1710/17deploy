# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bvHr6WJuFka2qe9bk1TTtsgv55Z1JhRV
"""

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import joblib

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import pandas as pd
# import numpy as np

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df=pd.read_csv("/content/Sales Data - Sales Data.csv")

df

df.head(10)

df.tail()

df.sample(15)

df.shape

df.columns

df.index

df.info()

df.dtypes

df.describe()

df.describe(include="all")

df.isnull().sum()

df['latest_customer_review'].isnull().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df[df.isnull().any(axis=1)]

df.duplicated().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['season']=df['season'].str.lower()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['season'].unique()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['nearest_warehouse']=df['nearest_warehouse'].str.lower()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['nearest_warehouse'].unique()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['is_happy_customer'].unique()

df.nunique()

df['coupon_discount'].value_counts()

df['delivery_charges'].min(),df['delivery_charges'].max()

df.select_dtypes(include='number').columns

df.select_dtypes(include='number').head()

df.select_dtypes(include='object').columns

df.select_dtypes(include='object').head()

df[df['coupon_discount'].between(10,15)]

df.groupby('date')['delivery_charges'].max()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df.drop('customer_lat',axis=1,inplace=True)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df.dropna(inplace=True)
#

df.shape

df.duplicated().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df.replace({'delivery_charges':'[$]'},'',regex=True,inplace=True)

df['delivery_charges']

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['delivery_charges']=df['delivery_charges'].apply(float)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['date']=pd.to_datetime(df['date'],errors='coerce')

df.isnull().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df.dropna(inplace=True)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import matplotlib.pyplot as plt
# import seaborn as sns
# from warnings import simplefilter
# simplefilter(action='ignore')

plt.hist(df['delivery_charges'],bins=9,edgecolor='k',color='red')
plt.title('Histogram of deliverycharges')
plt.xlabel('delivery_charges')
plt.ylabel('frequency')
plt.show()

sns.histplot(df['delivery_charges'],bins=9,edgecolor='r',color='green',kde=True)
plt.title('Histogram of deliverycharges')
plt.xlabel('delivery_charges')
plt.ylabel('frequency')
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# numcolumns=df.select_dtypes(include=['float','int'])
# numcolumns

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# categoricalcolumns=df.select_dtypes(include='object')
# categoricalcolumns

for i in numcolumns:
  plt.hist(df[i],bins=10,edgecolor='r',color='blue')
  plt.title('Histogram')
  plt.xlabel(i)
  plt.ylabel('Distribution')
  plt.show()

numcolumns.describe()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# for i in numcolumns.columns:
#   sns.boxplot(data=numcolumns,x=i,color='orange')
#   plt.title(i)
#   plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# Q1=df['order_price'].quantile(0.25)
# Q3=df['order_price'].quantile(0.75)
# IQR=Q3-Q1
# lower_bound=Q1-(1.5*IQR)
# upper_bound=Q3+(1.5*IQR)
# print(Q1,Q3)
# print(lower_bound,upper_bound)
# df = df[(df['order_price'] >= lower_bound) & (df['order_price'] <= upper_bound)]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# plt.boxplot(df['order_price'])
# plt.show()

numcolumns.columns

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# Q1=df['delivery_charges'].quantile(0.25)
# Q3=df['delivery_charges'].quantile(0.75)
# IQR=Q3-Q1
# lower_bound=Q1-(1.5*IQR)
# upper_bound=Q3+(1.5*IQR)
# print(Q1,Q3)
# print(lower_bound,upper_bound)
# df= df[(df['delivery_charges'] >= lower_bound) & (df['delivery_charges'] <= upper_bound)]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# plt.boxplot(df['delivery_charges'])
# plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# Q1=df['distance_to_nearest_warehouse'].quantile(0.25)
# Q3=df['distance_to_nearest_warehouse'].quantile(0.75)
# IQR=Q3-Q1
# lower_bound=Q1-(1.5*IQR)
# upper_bound=Q3+(1.5*IQR)
# print(Q1,Q3)
# print(lower_bound,upper_bound)
# df = df[(df['distance_to_nearest_warehouse'] >= lower_bound) & (df['distance_to_nearest_warehouse'] <= upper_bound)]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# plt.boxplot(df['distance_to_nearest_warehouse'])
# plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# Q1=df['order_total'].quantile(0.25)
# Q3=df['order_total'].quantile(0.75)
# IQR=Q3-Q1
# lower_bound=Q1-(1.5*IQR)
# upper_bound=Q3+(1.5*IQR)
# print(Q1,Q3)
# print(lower_bound,upper_bound)
# df = df[(df['order_total'] >= lower_bound) & (df['order_total'] <= upper_bound)]

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# plt.boxplot(df['order_total'])
# plt.show()

categoricalcolumns.columns

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# for i in categoricalcolumns.columns:
#   if i not in ['order_id','customer_id','shopping_cart','latest_customer_review']:
#     plt.figure(figsize=(10, 5))
#     sns.countplot(data=df, x=i, palette='dark')
#     plt.title(f'Frequency Distribution of {i}')
#     plt.show()

df['season'].value_counts()

for i in categoricalcolumns:
    if i not in ['order_id','customer_id','shopping_cart','latest_customer_review'] :
        plt.figure(figsize=(15,10))
        counts=df[i].value_counts()
        plt.pie(counts,labels=counts.index,autopct='%.1f%%',startangle=170)
        plt.title(i)

numcolumns.columns

plt.figure(figsize=(10, 5))
plt.scatter(df['order_total'],df['delivery_charges'])
plt.title('Scatter Plot of delivery_charges vs. order_total')
plt.xlabel('order_total')
plt.ylabel('delivery_charges')

plt.figure(figsize=(10, 5))
plt.scatter(df['delivery_charges'],df['distance_to_nearest_warehouse'])
plt.title('Scatter Plot of distance_to_nearest_warehouse vs. delivery_charges')
plt.xlabel('delivery_charges')
plt.ylabel('distance_to_nearest_warehouse')

df.columns

pd.crosstab(columns=df['season'],index=df['coupon_discount'])

pd.crosstab(columns=df['season'],index=df['coupon_discount']).plot(kind='barh',figsize=(6,6))

df['coupon_discount'].value_counts().plot(kind='pie',autopct="%.1f",startangle = 270)

df.groupby('season')['coupon_discount'].sum().reset_index()

plt.figure(figsize=(10, 5))
average_discount = df.groupby('season')['coupon_discount'].sum().reset_index()
print(average_discount)
plt.plot(average_discount['season'].astype('str'),average_discount['coupon_discount'],marker='p',linewidth = 1)
plt.title('Total discount Over Seasons')
plt.xlabel('Season')
plt.ylabel('discount')

numcolumns.corr()

correlation_matrix = numcolumns.corr()
plt.figure(figsize=(9, 6))
sns.heatmap(correlation_matrix,annot=True,fmt=".2f")
plt.title('Correlation Heatmap of sales Statistics')
plt.show()

from sklearn.utils import resample
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import OrdinalEncoder
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler, StandardScaler

labelencoder = LabelEncoder()
happiness_encoded_df = pd.DataFrame(labelencoder.fit_transform(df[['is_happy_customer']]), columns=['happiness_encoded'])
df_merged = pd.concat([df.drop('is_happy_customer', axis=1), happiness_encoded_df], axis=1)
display(df_merged.head())

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['nearest_warehouse']=df['nearest_warehouse'].replace({'thompson':0,'nickolson':1,'bakers':2})

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['nearest_warehouse'].value_counts()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['season']=df['season'].replace({'spring':0,'summer':1,'autumn':2,'winter':3})

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df['season'].value_counts()

df.shape

df.isnull().sum()

df.duplicated().sum()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# df.dropna(inplace=True)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# from sklearn.model_selection import train_test_split
# X=df[numcolumns.columns]
# y=df['is_happy_customer']
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.01, random_state=42)
# print("X_train:\n", X_train)
# print("X_test:\n", X_test)
# print("y_train:\n", y_train)
# print("y_test:\n", y_test)

df['is_happy_customer'].value_counts()

df['is_happy_customer'].shape

(295/421)*100

(126/421)*100

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# from imblearn.over_sampling import SMOTE
# smote=SMOTE(sampling_strategy='minority')
# X_res,y_res=smote.fit_resample(X,y)
# y_res.value_counts()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# X_train,X_test,y_train,y_test=train_test_split(X_res, y_res,test_size=0.2)
# X_train.shape,X_test.shape,y_train.shape,y_test.shape

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# from sklearn.ensemble import RandomForestClassifier

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# model=RandomForestClassifier(criterion='gini', n_estimators = 50)
# model.fit(X_train,y_train)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# model.score(X_test,y_test)

model.score(X_train,y_train)

from sklearn.metrics import confusion_matrix

y_pred=model.predict(X_test)
y_test=np.array(y_test)

cm=confusion_matrix(y_test,y_pred)
cm

numcolumns.columns

df['distance_to_nearest_warehouse'].max(),df['distance_to_nearest_warehouse'].min()

import joblib
joblib.dump(model, "model.joblib")
model = joblib.load("model.joblib")

print("Prediction:", model.predict([[5115,91.19,144.953757,5,4950.44,1.4086]]))

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import joblib
# from sklearn.ensemble import RandomForestClassifier
# from sklearn.model_selection import train_test_split
# X=df[numcolumns.columns]
# y=df['is_happy_customer']
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.01, random_state=42)
# print("X_train:\n", X_train)
# print("X_test:\n", X_test)
# print("y_train:\n", y_train)
# print("y_test:\n", y_test)
# from imblearn.over_sampling import SMOTE
# smote=SMOTE(sampling_strategy='minority')
# X_res,y_res=smote.fit_resample(X,y)
# y_res.value_counts()
# X_train,X_test,y_train,y_test=train_test_split(X_res, y_res,test_size=0.2)
# X_train.shape,X_test.shape,y_train.shape,y_test.shape
# model=RandomForestClassifier(criterion='gini', n_estimators = 50)
# model.fit(X_train,y_train)
# joblib.dump(model, "model.joblib")
# model = joblib.load("model.joblib")
# st.title("Customer Satisfication")
# st.write("Enter the metrics to classify customer satisfaction")
# 
# order_price = st.number_input("order price", min_value=585.0,max_value=35180.0,step=0.1)
# delivery_charges  = st.number_input("deliverycharges", min_value=46.35, max_value=107.58,step=0.1)
# customer_long = st.number_input("customerlong", min_value=144.9272705,max_value=145.0198375, step=0.1)
# coupon_discount = st.number_input("coupondiscount", min_value=0.0, max_value=20.0,step=0.1)
# order_total = st.number_input("ordertotal", min_value=639.29,max_value=33947.06, step=0.1)
# distance_to_nearest_warehouse = st.number_input("distance_to_nearest_warehouse", min_value=0.1078,max_value=2.2493, step=0.1)
# if st.button("Predict"):
#   features = np.array([[order_price, delivery_charges, customer_long,coupon_discount,order_total, distance_to_nearest_warehouse]])
#   prediction = model.predict(features)[0]
#   st.success(f"ðŸŒ¼ Predicted: {prediction}")